/*
Deployment script for db_exion

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "db_exion"
:setvar DefaultFilePrefix "db_exion"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL15.SQLEXPRESS02\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL15.SQLEXPRESS02\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Creating Table [dbo].[tblcuenta]...';


GO
CREATE TABLE [dbo].[tblcuenta] (
    [cid]   INT             IDENTITY (1, 1) NOT NULL,
    [saldo] DECIMAL (20, 2) NULL,
    CONSTRAINT [pk_tblcuenta] PRIMARY KEY CLUSTERED ([cid] ASC)
);


GO
PRINT N'Creating Table [dbo].[tblemisor]...';


GO
CREATE TABLE [dbo].[tblemisor] (
    [eid]    INT             IDENTITY (1, 1) NOT NULL,
    [nombre] VARCHAR (50)    NOT NULL,
    [stock]  INT             NOT NULL,
    [precio] DECIMAL (20, 2) NOT NULL,
    CONSTRAINT [pk_tblemisor] PRIMARY KEY CLUSTERED ([eid] ASC)
);


GO
PRINT N'Creating Table [dbo].[tblorden]...';


GO
CREATE TABLE [dbo].[tblorden] (
    [oid]           INT      IDENTITY (1, 1) NOT NULL,
    [cid]           INT      NOT NULL,
    [toid]          INT      NOT NULL,
    [eid]           INT      NOT NULL,
    [acciones]      INT      NOT NULL,
    [fecharegistro] DATETIME NOT NULL,
    CONSTRAINT [pk_tblorden] PRIMARY KEY CLUSTERED ([oid] ASC)
);


GO
PRINT N'Creating Table [dbo].[tbltipooperacion]...';


GO
CREATE TABLE [dbo].[tbltipooperacion] (
    [toid]        INT          IDENTITY (1, 1) NOT NULL,
    [descripcion] VARCHAR (50) NOT NULL,
    CONSTRAINT [pk_tbltipooperacion] PRIMARY KEY CLUSTERED ([toid] ASC)
);


GO
PRINT N'Creating Default Constraint unnamed constraint on [dbo].[tblorden]...';


GO
ALTER TABLE [dbo].[tblorden]
    ADD DEFAULT getdate() FOR [fecharegistro];


GO
PRINT N'Creating Foreign Key [dbo].[fk_tblcuenta]...';


GO
ALTER TABLE [dbo].[tblorden] WITH NOCHECK
    ADD CONSTRAINT [fk_tblcuenta] FOREIGN KEY ([cid]) REFERENCES [dbo].[tblcuenta] ([cid]);


GO
PRINT N'Creating Foreign Key [dbo].[fk_tbltipooperacion]...';


GO
ALTER TABLE [dbo].[tblorden] WITH NOCHECK
    ADD CONSTRAINT [fk_tbltipooperacion] FOREIGN KEY ([toid]) REFERENCES [dbo].[tbltipooperacion] ([toid]);


GO
PRINT N'Creating Foreign Key [dbo].[fk_tblemisor]...';


GO
ALTER TABLE [dbo].[tblorden] WITH NOCHECK
    ADD CONSTRAINT [fk_tblemisor] FOREIGN KEY ([eid]) REFERENCES [dbo].[tblemisor] ([eid]);


GO
PRINT N'Creating Procedure [dbo].[spi_cuenta]...';


GO
CREATE PROCEDURE [dbo].[spi_cuenta]
(
	@Request		nvarchar(max)
)
as
begin
	declare @saldo decimal(20, 2)
	declare @tbl as table(cid int, saldo decimal(20, 2))

	begin try
		select @saldo = json_value(@Request, '$.saldo')

		insert into
			tblcuenta
		output
			inserted.cid
			, inserted.saldo
		into @tbl
		values
			(
				@saldo
			)

		select	[Response] =
			(
				select	[id]		= cid
						, [cash]	= saldo
				from @tbl
				for json path, without_array_wrapper
			)
	end try
	begin catch
		declare @emesage varchar(800) = 'SP_Name: ' + error_procedure() + '|Line: ' + cast(error_line() as varchar(5)) + '|Error: ' + error_message();

		select	[Response] = '{"errors":["' + @emesage + '"]}'
	end catch
end
GO
PRINT N'Creating Procedure [dbo].[spi_orden]...';


GO
CREATE PROCEDURE [dbo].[spi_orden]
(
	@Request		nvarchar(max)
	, @Error		nvarchar(max) output
)
as
begin
	declare @saldo decimal(20, 2)
			, @nsaldo decimal(20, 2)
			, @stock int
			, @nstock int
			, @precio decimal(20, 2)
			, @acciones int
			, @aacciones int
			, @nacciones int
			, @currenttime time = cast(getdate() as time)
			, @tipooperacion int

	declare @tblerror table(error nvarchar(100))
	declare @tbl table(id int identity(1, 1), cid int, toid int, eid int, acciones int, fecharegistro datetime)

	--begin transaction
	begin try
		/* Se parsea la cadena json a datos dentro de una tabla */
		insert into @tbl
			select	orden.*
			from openjson(@Request)
			with
				(
					cid					int 'strict $.cid'
					, toid				int '$.toid'
					, eid				int '$.eid'
					, acciones			int '$.acciones'
					, fecharegistro		datetime '$.fecharegistro'
				) as orden

		/* Se obtienen los datos a validar */
		select	@saldo = c.saldo
				, @nsaldo = case when t.toid = 1 then c.saldo - (e.precio * t.acciones) else c.saldo + (e.precio * t.acciones) end
				, @stock = e.stock
				, @nstock = case when t.toid = 1 then e.stock - t.acciones else e.stock + t.acciones end
				, @precio = e.precio * t.acciones
				, @acciones = t.acciones
				, @aacciones = isnull(o.acciones, 0)
				, @nacciones = case when t.toid = 1 then @aacciones + t.acciones else @aacciones - t.acciones end
				, @tipooperacion = t.toid
		from @tbl				t
		inner join tblcuenta	c
			on c.cid = t.cid
		inner join tblemisor	e
			on e.eid = t.eid
		left join tblorden		o
			on o.cid = t.cid
			and o.eid = t.eid

		/* Validacions por regla de negocio */
		if @tipooperacion = 1 and (@precio > isnull(@saldo, 0))
			begin
				insert into @tblerror values('Saldo insuficiente para realizar la compra.')
			end

		if @tipooperacion = 2 and @acciones > @aacciones
			begin
				insert into @tblerror values('El stock de la cuenta es insuficiente para realizar la venta.')
			end

		if @acciones > @stock
			begin
				insert into @tblerror values('El stock del emisor es insuficiente para realizar la compra.')
			end

		if @currenttime <= '06:00:00' or @currenttime >= '15:00:00'
			begin
				insert into @tblerror values('Mercado cerrado.')
			end
		
		if @tipooperacion not in (1, 2)
			begin
				insert into @tblerror values('Operación no válida.')
			end

		if not exists(select * from @tblerror)
			begin
				/* Actualiza los datos de la orden o la inserta en caso de no existir */
				merge tblorden			o
				using @tbl				t
					on o.cid = t.cid
					and o.eid = t.eid
				when matched then update
				set 
					o.acciones	= @nacciones
					, o.toid	= @tipooperacion
				when not matched then insert
				(
					cid
					, toid
					, eid
					, acciones
					, fecharegistro
				)
				values
				(
					t.cid
					, t.toid
					, t.eid
					, t.acciones
					, t.fecharegistro
				)
				output 
					inserted.cid
					, inserted.toid
					, inserted.eid
					, inserted.acciones
					, inserted.fecharegistro
				into @tbl;

				/* Actualiza el saldo de la cuenta */
				update	c
					set c.saldo = @nsaldo
				from tblcuenta			c
				inner join @tbl			t
					on c.cid = t.cid

				/* Actualiza el stock de acciones del emisor */
				update	e
					set e.stock = @nstock
				from tblemisor			e
				inner join @tbl			t
					on e.eid = t.eid
			end

		if @@trancount > 0
			begin
                commit;
			end

		select	@Error = N'["' + string_agg(error, '","') + '"]'
		--select	@Error = string_agg(error, '|')
		from @tblerror

		--select	c.saldo
		--		, e.nombre
		--		, e.precio
		--from @tbl					t
		--inner join tblcuenta		c
		--	on t.cid = c.cid
		--inner join tblemisor		e
		--	on t.eid = e.eid
		--for json auto
	end try
	begin catch
		if @@trancount > 0
			begin
                rollback;
			end

		declare @emesage varchar(800) = 'SP_Name: ' + error_procedure() + '|Line: ' + cast(error_line() as varchar(5)) + '|Error: ' + error_message();

		set @Error = '["' + @emesage + '"]'
	end catch
end
GO
PRINT N'Creating Procedure [dbo].[sp_procesaorden]...';


GO
CREATE PROCEDURE [dbo].[sp_procesaorden]
(
	@Request		nvarchar(max)
)
as
begin
	declare @counter int = 1
			, @maxid int
			, @json nvarchar(max)
			, @strerror nvarchar(max)

	declare @tbl table(id int identity(1, 1), json nvarchar(max))
	declare @result table(id int identity(1, 1), cid int, eid int, acciones int, error nvarchar(max))

	--begin tran
	begin try
		insert into @tbl
			select value from openjson(@Request)

		select @maxid = max(id) from @tbl
		while @counter <= @maxid
			begin
				select @json = json from @tbl where id = @counter

				exec spi_orden @json, @strerror output

				insert into @result
					select	orden.cid, orden.eid, orden.acciones, @strerror
					from openjson(@json)
					with
						(
							cid					int 'strict $.cid'
							, eid				int '$.eid'
							, acciones			int '$.acciones'
						) as orden

				set @counter += 1;
			end

		select	[Response] =
			(
				select	[cash]				= current_balance.saldo
						, [issuer_name]		= issuers.nombre
						, [total_shares]	= issuers.acciones
						, [share_price]		= issuers.precio
						, [business_errors] = issuers.error
				from tblcuenta		current_balance
				inner join @result	r
					on current_balance.cid = r.cid
				right outer join
					(
						select	i.nombre
								, ri.acciones
								, i.precio
								, ri.id
								, [error]	= isnull(ri.error, '')
						from @result ri
						inner join tblemisor i
							on ri.eid = i.eid
					)				issuers
					on issuers.id = r.id
				group by
					r.id
					, r.cid
					, current_balance.saldo
					, r.eid
					, issuers.acciones
					, issuers.nombre
					, issuers.precio
					, issuers.error
				for json auto, without_array_wrapper
			)
		
		--commit;
	end try
	begin catch
		--rollback;
		declare @emesage varchar(800) = 'SP_Name: ' + error_procedure() + '|Line: ' + cast(error_line() as varchar(5)) + '|Error: ' + error_message();

		select	[Response] = '{"errors":["' + @emesage + '"]}'
	end catch
end
GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [dbo].[tblorden] WITH CHECK CHECK CONSTRAINT [fk_tblcuenta];

ALTER TABLE [dbo].[tblorden] WITH CHECK CHECK CONSTRAINT [fk_tbltipooperacion];

ALTER TABLE [dbo].[tblorden] WITH CHECK CHECK CONSTRAINT [fk_tblemisor];


GO
PRINT N'Update complete.';


GO
